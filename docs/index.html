<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gold Pixel — MVP</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121926; --text:#e7eef8; --muted:#9fb0c5; --stroke:#223047; }
    * { box-sizing: border-box; }
    body {
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg); color: var(--text);
      display:flex; min-height:100vh;
    }
    .left {
      width: 320px; padding:16px; border-right:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(18,25,38,.98), rgba(11,15,20,.98));
    }
    h1 { margin:0 0 6px 0; font-size:18px; }
    .sub { color: var(--muted); font-size:12px; margin-bottom:12px; line-height:1.4; }
    .card {
      border:1px solid var(--stroke); background: rgba(255,255,255,0.03);
      border-radius:12px; padding:12px; margin-bottom:12px;
    }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn {
      border:1px solid var(--stroke); background: rgba(255,255,255,.04);
      color: var(--text); padding:8px 10px; border-radius:10px; cursor:pointer;
      font-size:13px;
    }
    .btn:hover { background: rgba(255,255,255,.08); }
    .btn.primary { border-color: #2f6fed; background: rgba(47,111,237,.18); }
    .btn.danger { border-color:#ff4d4d; background: rgba(255,77,77,.12); }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--stroke); border-radius:999px; padding:6px 10px;
      font-size:12px; color: var(--muted);
    }
    .swatches { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .swatch {
      width:28px; height:28px; border-radius:8px; border:2px solid rgba(255,255,255,.10);
      cursor:pointer; position:relative;
    }
    .swatch.active { outline: 2px solid #ffffff; outline-offset: 2px; }
    .label { font-size:12px; color: var(--muted); margin-bottom:6px; }
    .stat { font-size:13px; }
    .small { font-size:12px; color: var(--muted); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:2px 6px; border:1px solid var(--stroke); border-radius:6px; color: var(--muted); }
    .main { flex:1; display:flex; flex-direction:column; }
    .topbar {
      padding:10px 12px; border-bottom:1px solid var(--stroke);
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .canvasWrap { position:relative; flex:1; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; background:#0a0f16; }
    .hint {
      position:absolute; left:12px; bottom:12px;
      background: rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.10);
      padding:10px 12px; border-radius:12px; color:#dbe7ff; font-size:12px;
      backdrop-filter: blur(6px);
    }
    .coords {
      position:absolute; right:12px; bottom:12px;
      background: rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.10);
      padding:8px 10px; border-radius:12px; color:#dbe7ff; font-size:12px;
      backdrop-filter: blur(6px);
      min-width: 140px; text-align:right;
    }
  </style>
</head>
<body>
  <aside class="left">
    <h1>Gold Pixel</h1>
    <div class="sub">
      Prototype MVP (local) — zoom/pan + placement + cooldown.<br>
      Plus tard, le serveur imposera le cooldown et l’anti-bot.
    </div>

    <div class="card">
      <div class="label">Pack</div>
      <div class="row">
        <button id="tierEssential" class="btn primary">Essentiel (60s)</button>
        <button id="tierElite" class="btn">Élite (30s)</button>
      </div>
      <div style="height:10px"></div>
      <div class="row">
        <span class="pill">Cooldown : <strong id="cooldownLabel" style="color:var(--text)">60s</strong></span>
        <span class="pill">Restant : <strong id="cooldownRemaining" style="color:var(--text)">0s</strong></span>
      </div>
      <div class="small" style="margin-top:8px;">
        ⚠️ MVP : le cooldown est local (client). En multi, il sera serveur-authoritative.
      </div>
    </div>

    <div class="card">
      <div class="label">Couleurs (bases)</div>
      <div id="swatches" class="swatches"></div>
      <div class="small" style="margin-top:10px;">
        Astuce : vous pouvez “écraser” un pixel en cliquant dessus.
      </div>
    </div>

    <div class="card">
      <div class="label">Actions</div>
      <div class="row">
        <button id="btnSave" class="btn">Sauver (local)</button>
        <button id="btnLoad" class="btn">Charger</button>
        <button id="btnReset" class="btn danger">Reset</button>
      </div>
      <div class="small" style="margin-top:10px;">
        Contrôles : <span class="kbd">Molette</span> zoom • <span class="kbd">Drag</span> déplacer • <span class="kbd">Clic</span> poser.
      </div>
    </div>

    <div class="card">
      <div class="label">Stats</div>
      <div class="stat">Pixels posés : <strong id="placedCount">0</strong></div>
      <div class="stat">Zoom : <strong id="zoomLabel">1.00x</strong></div>
      <div class="small" style="margin-top:8px;">
        Grille visible automatiquement quand le zoom est suffisant.
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <div>
        <strong>Toile mondiale (MVP local)</strong>
        <span class="small"> — 512×512</span>
      </div>
      <div class="small">
        Conseil perf : évitez de zoomer à fond en plein écran sur de vieux PC (même si c’est fun).
      </div>
    </div>
    <div class="canvasWrap">
      <canvas id="c"></canvas>
      <div class="hint">
        Posez des pixels. Dans la version online, tout le monde verra les changements en temps réel.
      </div>
      <div class="coords" id="coords">x: — • y: —</div>
    </div>
  </main>

<script>
(() => {
  // ====== Config MVP ======
  const GRID_W = 512, GRID_H = 512;

  // Couleurs "bases" (sans nuances)
  const BASE_COLORS = [
    { name: "Blanc",   hex: "#FFFFFF" },
    { name: "Noir",    hex: "#000000" },
    { name: "Rouge",   hex: "#FF0000" },
    { name: "Vert",    hex: "#00FF00" },
    { name: "Bleu",    hex: "#0000FF" },
    { name: "Jaune",   hex: "#FFFF00" },
    { name: "Orange",  hex: "#FFA500" },
    { name: "Violet",  hex: "#8000FF" },
    { name: "Rose",    hex: "#FF00FF" },
    { name: "Cyan",    hex: "#00FFFF" },
    { name: "Marron",  hex: "#8B4513" },
    { name: "Gris",    hex: "#808080" },
  ];

  // Cooldowns
  const COOLDOWN_ESSENTIAL = 60;
  const COOLDOWN_ELITE = 30;

  // ====== DOM ======
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  const swatchesEl = document.getElementById("swatches");
  const tierEssentialBtn = document.getElementById("tierEssential");
  const tierEliteBtn = document.getElementById("tierElite");
  const cooldownLabel = document.getElementById("cooldownLabel");
  const cooldownRemainingEl = document.getElementById("cooldownRemaining");
  const placedCountEl = document.getElementById("placedCount");
  const zoomLabelEl = document.getElementById("zoomLabel");
  const coordsEl = document.getElementById("coords");

  const btnSave = document.getElementById("btnSave");
  const btnLoad = document.getElementById("btnLoad");
  const btnReset = document.getElementById("btnReset");

  // ====== State ======
  let selectedColor = BASE_COLORS[2].hex; // rouge par défaut
  let tier = "essential"; // "essential" | "elite"
  let cooldownSeconds = COOLDOWN_ESSENTIAL;
  let nextAllowedAt = 0; // timestamp ms
  let placedCount = 0;

  // Camera (zoom/pan)
  let scale = 1.2;     // zoom initial
  let offsetX = 0;     // translation écran
  let offsetY = 0;
  let isPanning = false;
  let panStart = { x:0, y:0, ox:0, oy:0 };

  // Backing image buffer: 512x512 pixels
  // On stocke du RGBA dans ImageData.
  const imgData = ctx.createImageData(GRID_W, GRID_H);
  // Remplir d’un fond sombre/transparent ? Ici on met noir au départ.
  for (let i = 0; i < imgData.data.length; i += 4) {
    imgData.data[i]   = 10;  // R
    imgData.data[i+1] = 15;  // G
    imgData.data[i+2] = 22;  // B
    imgData.data[i+3] = 255; // A
  }

  // ====== Utils ======
  function hexToRgb(hex) {
    const s = hex.replace("#", "").trim();
    const v = parseInt(s, 16);
    return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
  }

  function setPixel(x, y, hex) {
    if (x < 0 || y < 0 || x >= GRID_W || y >= GRID_H) return;
    const { r,g,b } = hexToRgb(hex);
    const idx = (y * GRID_W + x) * 4;
    imgData.data[idx] = r;
    imgData.data[idx+1] = g;
    imgData.data[idx+2] = b;
    imgData.data[idx+3] = 255;
  }

  function getWorldFromScreen(sx, sy) {
    // inverse transform: world pixel coords (float)
    const x = (sx - offsetX) / scale;
    const y = (sy - offsetY) / scale;
    return { x, y };
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function resizeCanvasToDisplaySize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    ctx.setTransform(1,0,0,1,0,0);
  }

  function fitInitialView() {
    // Centre la toile dans l’écran
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.width, h = canvas.height;
    // On garde scale actuel, mais on centre
    offsetX = (w / dpr - GRID_W * scale) / 2;
    offsetY = (h / dpr - GRID_H * scale) / 2;
  }

  function drawGridOverlay() {
    // Affiche une grille seulement si on voit bien les pixels
    if (scale < 8) return;
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    // Lignes de grille (tous les 1 px)
    ctx.lineWidth = 1 / scale;
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath();

    // Pour perf: ne dessiner que la zone visible
    const viewW = canvas.getBoundingClientRect().width;
    const viewH = canvas.getBoundingClientRect().height;
    const topLeft = getWorldFromScreen(0, 0);
    const bottomRight = getWorldFromScreen(viewW, viewH);

    const x0 = clamp(Math.floor(topLeft.x), 0, GRID_W);
    const y0 = clamp(Math.floor(topLeft.y), 0, GRID_H);
    const x1 = clamp(Math.ceil(bottomRight.x), 0, GRID_W);
    const y1 = clamp(Math.ceil(bottomRight.y), 0, GRID_H);

    for (let x = x0; x <= x1; x++) {
      ctx.moveTo(x + 0.5, y0);
      ctx.lineTo(x + 0.5, y1);
    }
    for (let y = y0; y <= y1; y++) {
      ctx.moveTo(x0, y + 0.5);
      ctx.lineTo(x1, y + 0.5);
    }
    ctx.stroke();
    ctx.restore();
  }

  function render() {
    resizeCanvasToDisplaySize();

    // Clear
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = "#0a0f16";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Draw imageData scaled + panned
    ctx.imageSmoothingEnabled = false; // pixel art net
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.putImageData(imgData, 0, 0);
    ctx.restore();

    // Grille
    drawGridOverlay();

    // UI labels
    zoomLabelEl.textContent = `${scale.toFixed(2)}x`;
    placedCountEl.textContent = String(placedCount);

    // Cooldown remaining
    const now = Date.now();
    const remaining = Math.max(0, Math.ceil((nextAllowedAt - now) / 1000));
    cooldownRemainingEl.textContent = `${remaining}s`;

    requestAnimationFrame(render);
  }

  // ====== UI: palette ======
  function buildSwatches() {
    swatchesEl.innerHTML = "";
    BASE_COLORS.forEach((c) => {
      const div = document.createElement("div");
      div.className = "swatch" + (c.hex === selectedColor ? " active" : "");
      div.title = c.name;
      div.style.background = c.hex;
      div.addEventListener("click", () => {
        selectedColor = c.hex;
        [...swatchesEl.children].forEach(ch => ch.classList.remove("active"));
        div.classList.add("active");
      });
      swatchesEl.appendChild(div);
    });
  }

  // ====== UI: tier ======
  function applyTier(newTier) {
    tier = newTier;
    if (tier === "elite") {
      cooldownSeconds = COOLDOWN_ELITE;
      tierEliteBtn.classList.add("primary");
      tierEssentialBtn.classList.remove("primary");
      cooldownLabel.textContent = `${COOLDOWN_ELITE}s`;
    } else {
      cooldownSeconds = COOLDOWN_ESSENTIAL;
      tierEssentialBtn.classList.add("primary");
      tierEliteBtn.classList.remove("primary");
      cooldownLabel.textContent = `${COOLDOWN_ESSENTIAL}s`;
    }
  }

  tierEssentialBtn.addEventListener("click", () => applyTier("essential"));
  tierEliteBtn.addEventListener("click", () => applyTier("elite"));

  // ====== Input: pan/zoom/click ======
  canvas.addEventListener("mousedown", (e) => {
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    panStart.ox = offsetX;
    panStart.oy = offsetY;
  });

  window.addEventListener("mouseup", () => { isPanning = false; });

  window.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    // coords overlay
    const w = getWorldFromScreen(sx, sy);
    const gx = Math.floor(w.x);
    const gy = Math.floor(w.y);
    if (gx >= 0 && gy >= 0 && gx < GRID_W && gy < GRID_H) {
      coordsEl.textContent = `x: ${gx} • y: ${gy}`;
    } else {
      coordsEl.textContent = `x: — • y: —`;
    }

    if (!isPanning) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    offsetX = panStart.ox + dx;
    offsetY = panStart.oy + dy;
  });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    // Zoom vers le pointeur
    const before = getWorldFromScreen(sx, sy);
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(scale * zoomFactor, 0.4, 60);

    // Ajuster offset pour garder le point sous la souris stable
    scale = newScale;
    const after = getWorldFromScreen(sx, sy);
    offsetX += (after.x - before.x) * scale;
    offsetY += (after.y - before.y) * scale;
  }, { passive: false });

  canvas.addEventListener("click", (e) => {
    // Ne pas confondre click et fin de pan (si on a bougé)
    if (Math.abs(e.clientX - panStart.x) > 3 || Math.abs(e.clientY - panStart.y) > 3) return;

    const now = Date.now();
    if (now < nextAllowedAt) return; // cooldown (MVP local)

    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const w = getWorldFromScreen(sx, sy);
    const x = Math.floor(w.x);
    const y = Math.floor(w.y);
    if (x < 0 || y < 0 || x >= GRID_W || y >= GRID_H) return;

    setPixel(x, y, selectedColor);
    placedCount++;
    nextAllowedAt = now + cooldownSeconds * 1000;
  });

  // ====== Save/Load/Reset ======
  const STORAGE_KEY = "goldpixel_mvp_canvas_v1";

  function saveToLocal() {
    const payload = {
      w: GRID_W,
      h: GRID_H,
      placedCount,
      // On stocke en base64 le buffer RGBA (assez gros mais OK pour MVP)
      data: btoa(String.fromCharCode(...imgData.data)),
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    alert("Sauvegardé en local ✅");
  }

  function loadFromLocal() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) { alert("Aucune sauvegarde trouvée."); return; }
    const payload = JSON.parse(raw);
    if (payload.w !== GRID_W || payload.h !== GRID_H) {
      alert("Sauvegarde incompatible (taille différente).");
      return;
    }
    const bytes = Uint8ClampedArray.from(atob(payload.data), c => c.charCodeAt(0));
    imgData.data.set(bytes);
    placedCount = payload.placedCount || 0;
    alert("Chargé ✅");
  }

  function resetAll() {
    if (!confirm("Reset la toile ?")) return;
    for (let i = 0; i < imgData.data.length; i += 4) {
      imgData.data[i]   = 10;
      imgData.data[i+1] = 15;
      imgData.data[i+2] = 22;
      imgData.data[i+3] = 255;
    }
    placedCount = 0;
    nextAllowedAt = 0;
  }

  btnSave.addEventListener("click", saveToLocal);
  btnLoad.addEventListener("click", loadFromLocal);
  btnReset.addEventListener("click", resetAll);

  // ====== Init ======
  buildSwatches();
  applyTier("essential");

  // Resize + initial centering
  const ro = new ResizeObserver(() => fitInitialView());
  ro.observe(document.querySelector(".canvasWrap"));

  // Première mise au point
  setTimeout(() => {
    resizeCanvasToDisplaySize();
    fitInitialView();
  }, 0);

  render();
})();
</script>
</body>
</html>
